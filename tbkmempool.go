package main

import (
//    "bufio"
    "bytes"
    "fmt"
    "log"
    "net/http"
    "os"
    "encoding/JSON"
	"strconv"
	"time"
)

// One fee in the JSON response
type AutoGenerated struct {
	Data []struct {
		FeeTx struct {
			BeforeLastBlock int `json:"before_last_block"`
			Conflicts int `json:"conflicts"`
			SinceLastBlock int `json:"since_last_block"`
		} `json:"fee_tx"`
		NTx struct {
			BeforeLastBlock int `json:"before_last_block"`
			Conflicts int `json:"conflicts"`
			SinceLastBlock int `json:"since_last_block"`
		} `json:"n_tx"`
		SizeTx struct {
			BeforeLastBlock int `json:"before_last_block"`
			Conflicts int `json:"conflicts"`
			SinceLastBlock int `json:"since_last_block"`
		} `json:"size_tx"`
		Time float64 `json:"time"`
		TxesPerMinute float64 `json:"txes_per_minute"`
		VolTx struct {
			BeforeLastBlock int64 `json:"before_last_block"`
			Conflicts int `json:"conflicts"`
			SinceLastBlock int64 `json:"since_last_block"`
		} `json:"vol_tx"`
	} `json:"data"`
}


func main() {

/*		    fd, err := os.Open("new_file.go")
    if err != nil {
        log.Fatal(err)
    }
*/
	
	hour,min := time.Now().Hour(), time.Now().Minute()
	_, month, day := time.Now().Date()
	h := strconv.Itoa(hour)
	n := strconv.Itoa(min)
	d := strconv.Itoa(day)
	m := strconv.Itoa(int(month))
	var buffer bytes.Buffer
	buffer.WriteString("MEMPL TBK")
	buffer.WriteString(m)
	buffer.WriteString("-")
	buffer.WriteString(d)
	buffer.WriteString("at")
	buffer.WriteString(h)
	buffer.WriteString(n)
	buffer.WriteString(".csv")
	xx := buffer.String()


	file, err :=os.Create(xx)
	if err != nil{
		fmt.Println("Cannot create")
	}
//		fmt.Fprintf(file,
//		"time", "fee since last", "fee before last", "tx since last", "tx before last", "size since", "size before", "txrate")
  
	defer file.Close()

//	var counter time.Duration = 1
	  ticker := time.NewTicker(time.Second * 11)
  
	  go func() {
	  for range ticker.C {
	    response, err := http.Get("https://tradeblock.com/api/blockchain/mempoolrecent/168/600")
    if err != nil {
        fmt.Println("ooops")
    }
    defer response.Body.Close()
  
  // JSON: {"minFee":1,"maxFee":10,"dayCount":7632,"memCount":6643,"minDelay":4,"maxDelay":50,"minMinutes":25,"maxMinutes":480},
  //  Columns in CSV: (ignore values above)
  //  minFee, maxFee, dayCount, memCount, minDelay, maxDelay, minMinutes, maxMinutes
  //131, 140, 7067, 21, 0, 0, 0, 25
  //this would work fine for each line

  dec := json.NewDecoder(response.Body)
  fees := AutoGenerated{}
  err = dec.Decode(&fees)
  if err != nil {
    log.Fatal("Failed to decode the JSON body:", err)
  }
  fmt.Printf("%+v", fees)
  

		

  for _, fee := range fees.Data {
    _, err := fmt.Fprintf(file, 
                          "%g,%d,%d,%d,%d,%d,%d,%g\n",
                          fee.Time, fee.FeeTx.SinceLastBlock, fee.FeeTx.BeforeLastBlock, fee.NTx.SinceLastBlock, fee.NTx.BeforeLastBlock, fee.SizeTx.SinceLastBlock, fee.SizeTx.BeforeLastBlock, fee.TxesPerMinute)
    fmt.Println(xx)
    if err != nil {
      log.Fatal("Could not write to CSV file:", err)
      
      
//      	  ticker := Ticker(time.Minute * 360)
      
    }
  }

//		ticker.C := (time.minute * 360)
  }
  }() 
  
  time.Sleep(time.Second * 19 )
  ticker.Stop()
}






