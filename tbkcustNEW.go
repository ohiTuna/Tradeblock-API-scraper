package main

import (
	"bytes"
	"encoding/csv"
	"encoding/json"
	//	"errors"
	"fmt"
	"log"
	"net/http"
	"os"
	"strconv"
	"time"
	"net/url"
)

// One fee in the JSON response
type AutoGenerated struct {
	Data []Stat `json:"data"`

	// apply patch and do side by side after running patched vers.
	// issue is in timer channel or in changing order of code change.
	// JSON unmarshel appears broken.
	// Check file ops and closing parens on main and filler
}

type Stat struct {
	Timestamp int //`json:"num_int"`
	Fee       json.Number `json:"num_float"`
}

func (s *Stat) UnmarshalJSON(data []byte) error {
	var tmp []int
	if s.Timestamp < 6000 {
		json.Unmarshal(data, &tmp)
	}
	s.Timestamp = tmp[0]

	var blk []json.Number
	if err := json.Unmarshal(data, &blk); err != nil {
		return err
	}
	s.Fee = blk[1]

	return nil
}

func main() {

	fmt.Println("Enter data type: txsize_new, txfee_new, txes_new, blocks_new")
	var inType string
	fmt.Scanf("%s", &inType)
	fmt.Println("Enter interval to query: 1h, 2h, 6h, 1d")
	var inInterval string
	fmt.Scanf("%s", &inInterval)
	fmt.Printf("Enter latest date value to pull: 1487008800 = Feb 13 2017 6PM, 86400=24hours")
	var inDate string
	//	var currentTimestamp int
	fmt.Scanf("%s", &inDate)
	fmt.Println("number of instances back to run?")
	var inRuns int
	fmt.Scanf("%v", &inRuns)
	time.Sleep(2000 * time.Millisecond)

	ruffer := filenamer(inType, inInterval)
	xx := ruffer.String()
	Filecsv, err := os.Create(xx)

	if err != nil {
		fmt.Println("Cannot create")
	}
	defer Filecsv.Close()

	currentTimestamp, err := strconv.Atoi(inDate)
	if err != nil {
		log.Fatalf("date conversion to int failed", err)
	}
	urls := make([]string, 0)
	lurl := fmt.Sprintf("https://tradeblock.com/api/blockchain/statistics/%s/%s/%d", inType,
		inInterval, currentTimestamp)
	urls = append(urls, lurl)
	dataset := make([]Stat, 0, 10000)

	for i := 0; i == inRuns; i++ {
		if inInterval == "1h" {
			currentTimestamp -= 3600000
		} else if inInterval == "2h" {
			currentTimestamp -= 7200000
		} else if inInterval == "6h" {
			currentTimestamp -= 21600000
		} else if inInterval == "1d" {
			currentTimestamp -= 86400000
		}
		urls = append(urls, lurl)

		for _, lurl := range urls {
			current := reader(urls)
			dataset = append(dataset, current...)
		}

//		reader(dataset)
		writes(dataset, Filecsv)
		writes(dataset)

	}
}

//func filler(getlurl string, Filecsv *os.File) {

func reader(urls []string) (fees []Stat) {

	for {
		response, err := http.Get(urls[1])
		if err != nil {
			log.Fatalf("failed to get JSON data: %v", err)
		}
		defer response.Body.Close()
		dec := json.NewDecoder(response.Body)
		dec.UseNumber()
		fees := AutoGenerated{}
		err = dec.Decode(&fees)
		if err != nil {
			log.Fatalf("Failed to decode the JSON body: %v", err)
		}
		noter := string("looks good")
		fmt.Printf(noter)

	}
	return fees

}
func writes(dataset []Stat, Filecsv *os.File) {
	csvw := csv.NewWriter(Filecsv)
	for _, fee := range fees.Data {
		var counter int = 1
		eqAa := "=(A"
		datecol2 := string("/24/60/60)+DATE(1970,1,1)")
		counter += 1
		numFee := fee.Fee.String()
		record := []string{strconv.Itoa(fee.Timestamp), numFee, eqAa + strconv.Itoa(counter) + datecol2}

		csvw.Flush()
		csvw.Write(record)

		if err := csvw.Error(); err != nil {
			log.Fatalf("Could not write to CSV file:", err)
		}
	}

}

func filenamer(inType, inInterval string) (bytes.Buffer) {
	//ugly timestamper for filename
	hour, min := time.Now().Hour(), time.Now().Minute()
	_, month, day := time.Now().Date()
	h := strconv.Itoa(hour)
	n := strconv.Itoa(min)
	d := strconv.Itoa(day)
	m := strconv.Itoa(int(month))
	var zuffer bytes.Buffer
	zuffer.WriteString(inType)
	zuffer.WriteString(inInterval)
	zuffer.WriteString("-")
	zuffer.WriteString(m)
	zuffer.WriteString("-")
	zuffer.WriteString(d)
	zuffer.WriteString("at")
	zuffer.WriteString(h)
	zuffer.WriteString(n)
	zuffer.WriteString(".csv")


	return zuffer
}
