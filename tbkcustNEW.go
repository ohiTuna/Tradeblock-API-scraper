package main

import (
	"bytes"
	"encoding/csv"
	"encoding/json"
	//	"errors"
	"fmt"
	"log"
	"net/http"
	"os"
	"strconv"
	"time"
//	"net/url"
)

// One fee in the JSON response
type AutoGenerated struct {
	Data []Stat `json:"data"`

	// apply patch and do side by side after running patched vers.
	// issue is in timer channel or in changing order of code change.
	// JSON unmarshel appears broken.
	// Check file ops and closing parens on main and filler
}

type Stat struct {
	Timestamp int //`json:"num_int"`
	FeeJ       json.Number `json:"num_float"`
}

func (s *Stat) UnmarshalJSON(data []byte) error {
	var tmp []int
	if s.Timestamp < 6000 {
		json.Unmarshal(data, &tmp)
	}
	s.Timestamp = tmp[0]

	var blk []json.Number
	if err := json.Unmarshal(data, &blk); err != nil {
		return err
	}
	s.FeeJ = blk[1]

	return nil
}

func main() {

	var inType string
	var inInterval string
	var inDate string
	var inRuns int

	fmt.Println("Enter data type: txsize_new, txfee_new, txes_new, blocks_new")
	fmt.Scanf("%s", &inType)
	fmt.Println("Enter interval to query: 1h, 2h, 6h, 1d")
	fmt.Scanf("%s", &inInterval)
	fmt.Printf("Enter latest date value to pull: 86400=24hours \n")
	t := time.Now()
	fmt.Println("Current time is: ",t.Unix())
	//	var currentTimestamp int
	fmt.Scanf("%s", &inDate)
	fmt.Println("number of instances back to run?")
	fmt.Scanf("%v", &inRuns)
	time.Sleep(2000 * time.Millisecond)

	ruffer := filenamer(inType, inInterval)
	xx := ruffer.String()
	Filecsv, err := os.Create(xx)
	fmt.Println("csv okay")
	if err != nil {
		fmt.Println("Cannot create")
	}
	defer Filecsv.Close()

	currentTimestamp, err := strconv.Atoi(inDate)
	if err != nil {
		log.Fatalf("date conversion to int failed", err)
	}
	fmt.Println(currentTimestamp)
	urls := make([]string, 0)



	for i := 0; i <= inRuns; i++ {
		fmt.Println("for loop started")
		lurl := fmt.Sprintf("https://tradeblock.com/api/blockchain/statistics/%s/%s/%d", inType,
			inInterval, currentTimestamp)
		urls = append(urls, lurl)
		fmt.Println(lurl, urls)

		if inInterval == "1h" {
			currentTimestamp -= 3600000
		} else if inInterval == "2h" {
			currentTimestamp -= 7200000
		} else if inInterval == "6h" {
			currentTimestamp -= 21600000
		} else if inInterval == "1d" {
			currentTimestamp -= 86400000
		}
	}

	fmt.Println(urls[0])
	//fmt.Println(urls[2])
	dataset := make([]Stat, 0, len(urls) * 1)
	fmt.Println("dataset made")
		for _, lurl := range urls {
			fmt.Println("ranging")
			Currentdat := reader(inRuns, lurl)
			fmt.Println("reader")
			dataset = append(dataset, Currentdat.Data...)
			fmt.Println("appending")
			//		reader(dataset)
//			writes(dataset, Filecsv)
		}
		fmt.Println("trying write")
		writes(dataset, Filecsv)
		fmt.Println("write done")

}

//func filler(getlurl string, Filecsv *os.File) {

func reader(inRuns int, urls ...string) (Currentdat AutoGenerated) {


	i:=0
		fmt.Println(urls[i])
		response, err := http.Get(urls[i])
		if err != nil {
			log.Fatalf("failed to get JSON data: %v", err)
		}
	//	defer response.Body.Close()
		dec := json.NewDecoder(response.Body)
		dec.UseNumber()
		Currentdat = AutoGenerated{}
		err = dec.Decode(&Currentdat)
		if err != nil {
			log.Fatalf("Failed to decode the JSON body: %v", err)
		}
		noter := string("looks good")
		fmt.Println(noter, i)
		i+=1


	return Currentdat

}
func writes(dataset []Stat, Filecsv *os.File) {
	csvw := csv.NewWriter(Filecsv)
	fmt.Println("start ranging")
	for _, Fee := range dataset {
		var counter int = 1
		eqAa := "=(A"
		datecol2 := string("/24/60/60)+DATE(1970,1,1)")
		counter += 1
		numFee := Fee.FeeJ.String()
		record := []string{strconv.Itoa(Fee.Timestamp), numFee, eqAa + strconv.Itoa(counter) + datecol2}

		csvw.Flush()
		csvw.Write(record)

		if err := csvw.Error(); err != nil {
			log.Fatalf("Could not write to CSV file:", err)
		}
	}
	return

}

func filenamer(inType, inInterval string) (bytes.Buffer) {
	//ugly timestamper for filename
	hour, min := time.Now().Hour(), time.Now().Minute()
	_, month, day := time.Now().Date()
	h := strconv.Itoa(hour)
	n := strconv.Itoa(min)
	d := strconv.Itoa(day)
	m := strconv.Itoa(int(month))
	var zuffer bytes.Buffer
	zuffer.WriteString(inType)
	zuffer.WriteString(inInterval)
	zuffer.WriteString("-")
	zuffer.WriteString(m)
	zuffer.WriteString("-")
	zuffer.WriteString(d)
	zuffer.WriteString("at")
	zuffer.WriteString(h)
	zuffer.WriteString(n)
	zuffer.WriteString(".csv")


	return zuffer
}
