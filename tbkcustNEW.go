package main

import (
	"bytes"
	"encoding/csv"
	"encoding/json"
	//	"errors"
	"fmt"
	"log"
	"net/http"
	"os"
	"strconv"
	"time"
)

// One fee in the JSON response
type AutoGenerated struct {
	Data []Stat `json:"data"`
}

type Stat struct {
	Timestamp int         //`json:"num_int"`
	Fee    json.Number `json:"num_float"`
}

func (s *Stat) UnmarshalJSON(data []byte) error {
	var tmp []int
	if s.Timestamp < 6000 {
		json.Unmarshal(data, &tmp)
	}
	s.Timestamp = tmp[0]

	var blk []json.Number
	if err := json.Unmarshal(data, &blk); err != nil {
		return err
	}
	s.Fee = blk[1]

	return nil
}


func main() {
	var rdurl2 string
	fmt.Println("Enter data type: txsize_new, txfee_new, txes_new, blocks_new")
	var inType string
	fmt.Scanf("%s", &inType)
	fmt.Println("Enter interval to query: 1h, 2h, 6h, 1d")
	var inInterval string
	fmt.Scanf("%s", &inInterval)
	fmt.Printf("Enter latest date value to pull: 1487008800 = Feb 13 2017 6PM, 86400=24hours")
	var inDate string
	//	var inDaten int
	fmt.Scanf("%s", &inDate)
	fmt.Println("number of instances back to run?")
	var inRuns int
	fmt.Scanf("%v", &inRuns)
	time.Sleep(2000 * time.Millisecond)

	inRunss := inRuns
	inDaten, err := strconv.Atoi(inDate)
		if err != nil {
			log.Fatalf("date conversion to int failed", err)
	}
//checks number of instances back user wants to run and meth instCalc creates URLs for calls
		for ;inRuns>1;{
			inRuns--
			instCalc(inRunss, inDaten, inType, inInterval, inDate)
			fmt.Println(rdurl2)
			fmt.Println("70 line")
		}

//URL string maker
	var bufUrl bytes.Buffer
	bufUrl.WriteString("https://tradeblock.com/api/blockchain/statistics/")
	bufUrl.WriteString(inType)
	bufUrl.WriteString("/")
	bufUrl.WriteString(inInterval)
	bufUrl.WriteString("/")
	bufUrl.WriteString(inDate)
	rdyUrl := bufUrl.String()

//ugly timestamper for filename
	hour, min := time.Now().Hour(), time.Now().Minute()
	_, month, day := time.Now().Date()
	h := strconv.Itoa(hour)
	n := strconv.Itoa(min)
	d := strconv.Itoa(day)
	m := strconv.Itoa(int(month))
	var zuffer bytes.Buffer
		zuffer.WriteString(inType)
		zuffer.WriteString(inInterval)
		zuffer.WriteString("-")
		zuffer.WriteString(m)
		zuffer.WriteString("-")
		zuffer.WriteString(d)
		zuffer.WriteString("at")
		zuffer.WriteString(h)
		zuffer.WriteString(n)
		zuffer.WriteString(".csv")
		xx := zuffer.String()

	Filecsv, err := os.Create(xx)

	if err != nil {
		fmt.Println("Cannot create")
	}
	defer Filecsv.Close()

//filler is method for actually writing retrieved data to csv
	filler(rdyUrl, Filecsv)

	for ; inRunss > 1; {
		inRunss--
		filler(rdurl2, Filecsv)
		fmt.Println(inRuns)
		fmt.Println(rdurl2)
		fmt.Println("110 line")
	}
fmt.Println(inRuns,inRunss)

}
func filler(geturl string, Filecsv *os.File) {

		csvw := csv.NewWriter(Filecsv)
		ticker := time.NewTicker(time.Second * 6)
		for range ticker.C {
			response, err := http.Get(geturl)
			if err != nil {
				log.Fatalf("failed to get JSON data: %v", err)
			}
			defer response.Body.Close()
			dec := json.NewDecoder(response.Body)
			dec.UseNumber()
			fees := AutoGenerated{}
			err = dec.Decode(&fees)
			if err != nil {
				log.Fatalf("Failed to decode the JSON body: %v", err)
			}
			noter := string("looks good")
			fmt.Printf(noter)
			csvw.Flush()
			var counter int = 0

			for _, fee := range fees.Data {
//				datecol := make([][]string, 0)
//				eqA := make([]string, 0)
//				eqA[counter] = "=(A"
				eqAa := "=(A"
/*				datecol = append(datecol, eqA)
				rowNum := make([]string, counter)
				rowNum[counter] = strconv.Itoa(counter)
				datecol = append(datecol, rowNum)
*/				datecol2 := string("/24/60/60)+DATE(1970,1,1)")
				counter += 1
				numFee := fee.Fee.String()
				record := []string{strconv.Itoa(fee.Timestamp), (numFee), eqAa+strconv.Itoa(counter)+datecol2}

				csvw.Flush()
				csvw.Write(record)

				if err := csvw.Error(); err != nil {
					log.Fatalf("Could not write to CSV file:", err)
				}
			}
			ticker.Stop()
			return
		}
	return
	}




func instCalc(inRunss int, inDaten int, inType, inInterval,inDate string) (rdurl2 string) {

		if inInterval == "1h" {
			inDaten -= 3600000
		} else if inInterval == "2h" {
			inDaten -= 7200000
		} else if inInterval == "6h" {
			inDaten -= 21600000
		} else if inInterval == "1d" {
			inDaten -= 86400000
		}

	inDatenb := string(strconv.Itoa(inDaten))
	var url2 bytes.Buffer
	url2.WriteString("https://tradeblock.com/api/blockchain/statistics/")
	url2.WriteString(inType)
	url2.WriteString("/")
	url2.WriteString(inInterval)
	url2.WriteString("/")
	url2.WriteString(inDatenb)
	rdurl2 = url2.String()
	fmt.Println(inRunss)
	fmt.Println(rdurl2)
	fmt.Println("198 line")
	return rdurl2
}